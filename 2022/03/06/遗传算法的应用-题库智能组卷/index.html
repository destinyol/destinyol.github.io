<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>探索遗传算法的应用-题库智能组卷 | pyf的日记</title><meta name="author" content="pyf"><meta name="copyright" content="pyf"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言 在我做一个教学系统的项目时，遇到了一个问题场景，需要实现一个题库的功能，存放许多携带不同参数的题目，并且可以按照教师的参数需求，进行智能随机组卷。 一开始我以为是个比较简单的问题，准备自己手写个简单算法，能实现效果就行，但随着题目和题库的大致模型构思完，题目的参数变多，需要考虑的问题、意外的情况太多，自己写的代码屡屡出现问题，最终决定选择一套系统的、成体系的算法来重构这部分代码。 上网查阅了">
<meta property="og:type" content="article">
<meta property="og:title" content="探索遗传算法的应用-题库智能组卷">
<meta property="og:url" content="https://destinyol.github.io/2022/03/06/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8-%E9%A2%98%E5%BA%93%E6%99%BA%E8%83%BD%E7%BB%84%E5%8D%B7/index.html">
<meta property="og:site_name" content="pyf的日记">
<meta property="og:description" content="前言 在我做一个教学系统的项目时，遇到了一个问题场景，需要实现一个题库的功能，存放许多携带不同参数的题目，并且可以按照教师的参数需求，进行智能随机组卷。 一开始我以为是个比较简单的问题，准备自己手写个简单算法，能实现效果就行，但随着题目和题库的大致模型构思完，题目的参数变多，需要考虑的问题、意外的情况太多，自己写的代码屡屡出现问题，最终决定选择一套系统的、成体系的算法来重构这部分代码。 上网查阅了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/07/11/NhOuKfUn253GePM.jpg">
<meta property="article:published_time" content="2022-03-06T03:09:05.000Z">
<meta property="article:modified_time" content="2025-04-04T06:07:41.411Z">
<meta property="article:author" content="pyf">
<meta property="article:tag" content="遗传算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/07/11/NhOuKfUn253GePM.jpg"><link rel="shortcut icon" href="https://s2.loli.net/2023/07/11/NhOuKfUn253GePM.jpg"><link rel="canonical" href="https://destinyol.github.io/2022/03/06/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8-%E9%A2%98%E5%BA%93%E6%99%BA%E8%83%BD%E7%BB%84%E5%8D%B7/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '探索遗传算法的应用-题库智能组卷',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="pyf的日记" type="application/atom+xml">
</head><body><div id="web_bg" style="background-color: #e5e5e5;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://s2.loli.net/2023/07/11/NhOuKfUn253GePM.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s2.loli.net/2023/07/12/H9bijZ6dhxDzmKp.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">pyf的日记</span></a><a class="nav-page-title" href="/"><span class="site-name">探索遗传算法的应用-题库智能组卷</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">探索遗传算法的应用-题库智能组卷</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-06T03:09:05.000Z" title="发表于 2022-03-06 11:09:05">2022-03-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-04T06:07:41.411Z" title="更新于 2025-04-04 14:07:41">2025-04-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B2%E4%BB%A3%E7%A0%81/">敲代码</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B2%E4%BB%A3%E7%A0%81/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="前言">前言</h2>
<p>在我做一个教学系统的项目时，遇到了一个问题场景，需要实现一个题库的功能，存放许多携带不同参数的题目，并且可以按照教师的参数需求，进行智能随机组卷。</p>
<p>一开始我以为是个比较简单的问题，准备自己手写个简单算法，能实现效果就行，但随着题目和题库的大致模型构思完，题目的参数变多，需要考虑的问题、意外的情况太多，自己写的代码屡屡出现问题，最终决定选择一套系统的、成体系的算法来重构这部分代码。</p>
<p>上网查阅了相关资料，找到了两种算法：1.回溯算法 2.遗传算法</p>
<p>在对比了两种算法的优劣之后，我选择了遗传算法，因为它更为可控，算法具有更好的收敛性，效率更高，并且相对来说消耗内存更少。</p>
<h2 id="遗传算法简介">遗传算法简介</h2>
<h3 id="算法的一些概念">算法的一些概念</h3>
<h4 id="概念1：基因和染色体">概念1：基因和染色体</h4>
<p>在遗传算法中，我们首先需要将要解决的问题映射成一个数学问题，也就是所谓的“数学建模”，那么这个问题的一个可行解即被称为一条“染色体”。一个可行解一般由多个元素构成，那么这每一个元素就被称为染色体上的一个“基因”。</p>
<p>比如说，对于如下函数而言，[1,2,3]、[1,3,2]、[3,2,1]均是这个函数的可行解（代进去成立即为可行解），那么这些可行解在遗传算法中均被称为染色体。</p>
<p>这些可行解一共有三个元素构成，那么在遗传算法中，每个元素就被称为组成染色体的一个基因。</p>
<h4 id="概念2：适应度函数">概念2：适应度函数</h4>
<p>在自然界中，似乎存在着一个上帝，它能够选择出每一代中比较优良的个体，而淘汰一些环境适应度较差的个人。那么在遗传算法中，如何衡量染色体的优劣呢？这就是由适应度函数完成的。适应度函数在遗传算法中扮演者这个“上帝”的角色。</p>
<p>遗传算法在运行的过程中会进行N次迭代，每次迭代都会生成若干条染色体。适应度函数会给本次迭代中生成的所有染色体打个分，来评判这些染色体的适应度，然后将适应度较低的染色体淘汰掉，只保留适应度较高的染色体，从而经过若干次迭代后染色体的质量将越来越优良。</p>
<h4 id="概念3：交叉">概念3：交叉</h4>
<p>遗传算法每一次迭代都会生成N条染色体，在遗传算法中，这每一次迭代就被称为一次“进化”。那么，每次进化新生成的染色体是如何而来的呢？——答案就是“交叉”，你可以把它理解为交配。</p>
<p>交叉的过程需要从上一代的染色体中寻找两条染色体，一条是爸爸，一条是妈妈。然后将这两条染色体的某一个位置切断，并拼接在一起，从而生成一条新的染色体。这条新染色体上即包含了一定数量的爸爸的基因，也包含了一定数量的妈妈的基因。</p>
<p>在每完成一次进化后，都要计算每一条染色体的适应度，然后采用如下公式计算每一条染色体的适应度概率。那么在进行交叉过程时，就需要根据这个概率来选择父母染色体。适应度比较大的染色体被选中的概率就越高。这也就是为什么遗传算法能保留优良基因的原因。</p>
<h4 id="概念4：变异">概念4：变异</h4>
<p>交叉能保证每次进化留下优良的基因，但它仅仅是对原有的结果集进行选择，基因还是那么几个，只不过交换了他们的组合顺序。这只能保证经过N次进化后，计算结果更接近于局部最优解，而永远没办法达到全局最优解，为了解决这一个问题，我们需要引入变异。</p>
<p>变异很好理解。当我们通过交叉生成了一条新的染色体后，需要在新染色体上随机选择若干个基因，然后随机修改基因的值，从而给现有的染色体引入了新的基因，突破了当前搜索的限制，更有利于算法寻找到全局最优解。</p>
<h4 id="概念5：复制">概念5：复制</h4>
<p>每次进化中，为了保留上一代优良的染色体，需要将上一代中适应度最高的几条染色体直接原封不动地复制给下一代。</p>
<p>假设每次进化都需生成N条染色体，那么每次进化中，通过交叉方式需要生成N-M条染色体，剩余的M条染色体通过复制上一代适应度最高的M条染色体而来。</p>
<h3 id="遗传算法的流程">遗传算法的流程</h3>
<p>在算法初始阶段，它会随机生成一组可行解，也就是第一代染色体。然后采用适应度函数分别计算每一条染色体的适应程度，并根据适应程度计算每一条染色体在下一次进化中被选中的概率。</p>
<p>通过“交叉”，生成N-M条染色体；再对交叉后生成的N-M条染色体进行“变异”操作；然后使用“复制”的方式生成M条染色体；</p>
<p>N条染色体生成完毕，紧接着分别计算N条染色体的适应度和下次被选中的概率。至此，一轮进化就完成了。</p>
<p><img src="https://s2.loli.net/2023/07/12/BFEPUmnlQqrAHTp.png" alt="1.png"></p>
<h2 id="遗传算法对组卷问题的实现">遗传算法对组卷问题的实现</h2>
<h3 id="求解目标">求解目标</h3>
<p>根据教师输入的试卷参数要求，用遗传算法从题库中抽取题目生成个体和种群，多次迭代进化最终达到预定期望。并探索总结出不同类型、个数的参数，即不同的个体基因编码种类对于最终求解的影响，以及研究种群在不同的进化参数下，对于迭代过程和结果的影响。</p>
<h3 id="限制条件">限制条件</h3>
<ol>
<li>教师输入的参数，例如题目数量，题目类型，题型分值，难度系数，章节。</li>
<li>题库内题目的数量，种类，难度</li>
</ol>
<h3 id="输入样例">输入样例</h3>
<p><img src="https://s2.loli.net/2023/07/12/ZLnQWAm1BlpDHgo.png" alt="2.png"></p>
<p>前端向后端传递输入参数，整合完最终的数据对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前端传给后端</span></span><br><span class="line"><span class="comment"> *      自动组卷参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">examinationPaperMakeConfig</span> &#123;</span><br><span class="line">    <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line">    Date date;</span><br><span class="line">    String openOrClose;</span><br><span class="line">    <span class="type">int</span> examinationCourseId;</span><br><span class="line">    Integer[] questionCounts;</span><br><span class="line">    Float[] questionScore;</span><br><span class="line">    Integer[] chapterRange;</span><br><span class="line">    <span class="type">int</span> difficulty;</span><br><span class="line">    <span class="type">int</span> <span class="variable">TotalMark</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法实现步骤">算法实现步骤</h3>
<h4 id="创建实体类和对应模型关系">创建实体类和对应模型关系</h4>
<ol>
<li>题目：成员变量 —&gt; 题目id、难度、题型</li>
<li>试卷个体：成员变量 —&gt; 试卷id，题目list、个体适应度、个体难度系数</li>
<li>试卷种群：成员变量 —&gt; 试卷list</li>
<li>遗传算法实现Service：成员变量 —&gt; 变异概率、锦标赛选择方法规模比例</li>
</ol>
<p><img src="https://s2.loli.net/2023/07/12/FuXdtoa5GiLEgDm.png" alt="3.png"></p>
<h4 id="具体实现原理">具体实现原理</h4>
<p>结合具体问题实现遗传算法，一开始我将试卷个体的难度系数以及不同的题目作为整数基因编码。题目的难度分为0，1，2三种难度，分别对应简单，中等，困难。</p>
<p><strong>试卷个体难度系数公式：</strong> （D-难度系数，d-题目难度，s-题目分值）</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mo>=</mo><mo stretchy="false">(</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>d</mi><mi>i</mi></msub><mo>×</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>100</mn></mrow><annotation encoding="application/x-tex">D=(∑_id_i×s_i )/100
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3277em;vertical-align:-1.2777em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/100</span></span></span></span></span></p>
<p>种群在初始化阶段会从数据库中随机抽取符合教师输入的规则r的对应若干个题目分别随机放入n个试卷个体内（n为种群规模），这一过程要避免一张试卷中出现重复题目。从而算出每个个体的适应度。</p>
<p><strong>试卷个体适应度公式：</strong>（ED为期望难度系数）</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo>=</mo><mn>1</mn><mo>−</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi>D</mi><mo>−</mo><mi>D</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">f=1-|ED-D|
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">∣</span></span></span></span></span></p>
<p>初始化构建完毕的种群，其中的个体应该满足总分</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">G=∑_is_i=100
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3277em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span></span></p>
<h4 id="具体实现步骤">具体实现步骤</h4>
<p>PS：只有实现过程的部分代码，可以阅读交流学习，光靠这部分代码无法完整运行整个流程。</p>
<p><img src="https://s2.loli.net/2023/07/12/wtliqOfduMGE4yg.png" alt="5.png"></p>
<ol>
<li>
<p>初始化。设置进化代数计数器，设置n作为种群规模，将抽取题库用到的Dao层控制器导入种群作为初始化工具，设置最大进化代数（避免死循环），如果算法要达到全局最优解可能要经过很多次的进化，这极大影响系统的性能。那么我们就可以在算法的精确度和系统效率之间寻找一个平衡点。我们可以事先设定一个可以接收的结果范围，当算法进行x次进化后，一旦发现了当前的结果已经在误差范围之内了，那么就终止算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 算法迭代入口函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">getExaminationPaper</span><span class="params">(String userId,examinationPaperMakeConfig rule)</span> &#123;</span><br><span class="line">       <span class="type">ExaminationPaper</span> <span class="variable">resultPaper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line">       <span class="comment">// 适应度期望值  0-1 的数  满分是1</span></span><br><span class="line">       <span class="type">double</span> <span class="variable">expand</span> <span class="operator">=</span> <span class="number">0.95</span>;</span><br><span class="line">       ExaminationPopulation population;</span><br><span class="line">       <span class="comment">// 初始化种群</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loop; i++) &#123;</span><br><span class="line">           <span class="comment">// 迭代计数器</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">runCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">           population = <span class="keyword">new</span> <span class="title class_">ExaminationPopulation</span>(<span class="number">25</span>, rule ,tExaminationQuestionDao,examinationDao );</span><br><span class="line">           <span class="keyword">if</span> (population.getErrorMsg()!=<span class="literal">null</span>)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;种群初始化失败，&quot;</span>+population.getErrorMsg());</span><br><span class="line">               <span class="keyword">return</span> Result.error(<span class="string">&quot;018&quot;</span>,population.getErrorMsg());</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;种群初始化完成，执行遗传算法进行迭代====================================&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;种群初始最优个体适应度：&quot;</span>+population.getMostFitOne().getAdaptationDegree());</span><br><span class="line">           <span class="keyword">while</span> (count &lt; runCount &amp;&amp; population.getMostFitOne().getAdaptationDegree() &lt; expand) &#123;</span><br><span class="line">               count++;</span><br><span class="line">               population = examinationAlgorithmRealizeService.evolvePopulation(population, rule);</span><br><span class="line">               System.out.println(<span class="string">&quot;第 &quot;</span> + count + <span class="string">&quot; 次进化，最优个体适应度为：&quot;</span> + population.getMostFitOne().getAdaptationDegree());</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;共进化： &quot;</span> + count +<span class="string">&quot; 次&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;最终迭代得出最优个体适应度为： &quot;</span>+population.getMostFitOne().getAdaptationDegree());</span><br><span class="line">           System.out.println(<span class="string">&quot;期望适应度为&quot;</span>+expand+<span class="string">&quot;(分值0-1分)： &quot;</span>+population.getMostFitOne().getAdaptationDegree());</span><br><span class="line">           resultPaper = population.getMostFitOne();</span><br><span class="line">           <span class="keyword">if</span> (resultPaper.getAdaptationDegree() &gt; expand)&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">ExaminationPaperResultQuestionId</span> <span class="variable">resultQuestionIds</span> <span class="operator">=</span> resultPaper.getAllQuestionIds();</span><br><span class="line">       resultQuestionIds.setRule(rule);</span><br><span class="line">       <span class="type">Map</span> <span class="variable">resMap</span> <span class="operator">=</span> Map.of(<span class="string">&quot;questionIdList&quot;</span>,resultQuestionIds.getQuestionIdList(),<span class="string">&quot;questionScore&quot;</span>,resultQuestionIds.getRule().getQuestionScore());</span><br><span class="line">       <span class="keyword">return</span> Result.success(resMap,<span class="string">&quot;组卷成功，与期望难度匹配度为: &quot;</span>+String.format(<span class="string">&quot;%.1f&quot;</span>,resultPaper.getAdaptationDegree()*<span class="number">100</span>)+<span class="string">&quot;%&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 试卷种群</span></span><br><span class="line"><span class="comment"> *      题型对应数字：单选0，多选1，判断2，填空3，简答4</span></span><br><span class="line"><span class="comment"> * （包含多套试卷）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExaminationPopulation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//试卷数组</span></span><br><span class="line">    <span class="keyword">private</span> ExaminationPaper[] papers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动组卷规则</span></span><br><span class="line">    examinationPaperMakeConfig rule;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化一种题型</span></span><br><span class="line"><span class="comment">     *      （从数据库中获取题目）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initializeQuestion</span><span class="params">(<span class="type">int</span> type, String errorMsg, ExaminationPaper paper)</span> &#123;</span><br><span class="line">        <span class="comment">//mybatis筛选器</span></span><br><span class="line">        QueryWrapper&lt;TExaminationQuestion&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">        wrapper.lambda().eq(TExaminationQuestion::getType,type);</span><br><span class="line">       					.eq(TExaminationQuestion::getIsApproved,<span class="number">1</span>);</span><br><span class="line">        				.in(TExaminationQuestion::getChapter,rule.getChapterRange());</span><br><span class="line">        <span class="comment">//题目数组</span></span><br><span class="line">        List&lt;TExaminationQuestion&gt; questionList = tExaminationQuestionDao.selectList(wrapper);</span><br><span class="line">        <span class="keyword">if</span> (questionList.size() &lt; rule.getQuestionCounts()[type]) &#123;</span><br><span class="line">            <span class="built_in">this</span>.initializeErrorMsg = errorMsg;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; questionNums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; questionList.size(); i++) &#123;</span><br><span class="line">            questionNums.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; rule.getQuestionCounts()[type]; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(questionNums.size());</span><br><span class="line">            <span class="comment">//试卷随机添加题目</span></span><br><span class="line">            paper.addQuestion(type,questionList.get(questionNums.get(index)));</span><br><span class="line">            <span class="comment">//移除该数组下表的题目，避免添加重复题目</span></span><br><span class="line">            questionNums.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化种群</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> populationSize 种群规模</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rule 规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExaminationPopulation</span><span class="params">(<span class="type">int</span> populationSize, examinationPaperMakeConfig rule,tExaminationQuestionDao questionDao,ExaminationDao eDao)</span> &#123;</span><br><span class="line">        <span class="comment">// Dao层控制器</span></span><br><span class="line">        <span class="built_in">this</span>.examinationDao = eDao;</span><br><span class="line">        <span class="built_in">this</span>.tExaminationQuestionDao = questionDao;</span><br><span class="line">        <span class="built_in">this</span>.rule = rule;</span><br><span class="line">        papers = <span class="keyword">new</span> <span class="title class_">ExaminationPaper</span>[populationSize];</span><br><span class="line">        ExaminationPaper paper;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; populationSize; i++) &#123;</span><br><span class="line">            <span class="comment">//创建一个新试卷个体</span></span><br><span class="line">            paper = <span class="keyword">new</span> <span class="title class_">ExaminationPaper</span>(i,rule.getTotalMark(),rule);</span><br><span class="line">            <span class="comment">// 单选题</span></span><br><span class="line">            <span class="keyword">if</span> (rule.getQuestionCounts()[<span class="number">0</span>] &gt; <span class="number">0</span> &amp;&amp; initializeErrorMsg == <span class="literal">null</span>) &#123;</span><br><span class="line">                initializeQuestion(<span class="number">0</span>,<span class="string">&quot;单选题数量不够&quot;</span>, paper);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 多选题</span></span><br><span class="line">            <span class="keyword">if</span> (rule.getQuestionCounts()[<span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; initializeErrorMsg == <span class="literal">null</span>) &#123;</span><br><span class="line">                initializeQuestion(<span class="number">1</span>,<span class="string">&quot;多选题数量不够&quot;</span>, paper);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断题</span></span><br><span class="line">            <span class="keyword">if</span> (rule.getQuestionCounts()[<span class="number">2</span>] &gt; <span class="number">0</span> &amp;&amp; initializeErrorMsg == <span class="literal">null</span>) &#123;</span><br><span class="line">                initializeQuestion(<span class="number">2</span>,<span class="string">&quot;判断题数量不够&quot;</span>, paper);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 填空题</span></span><br><span class="line">            <span class="keyword">if</span> (rule.getQuestionCounts()[<span class="number">3</span>] &gt; <span class="number">0</span> &amp;&amp; initializeErrorMsg == <span class="literal">null</span>) &#123;</span><br><span class="line">                initializeQuestion(<span class="number">3</span>,<span class="string">&quot;填空题数量不够&quot;</span>, paper);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 简答题</span></span><br><span class="line">            <span class="keyword">if</span> (rule.getQuestionCounts()[<span class="number">4</span>] &gt; <span class="number">0</span> &amp;&amp; initializeErrorMsg == <span class="literal">null</span>) &#123;</span><br><span class="line">                initializeQuestion(<span class="number">4</span>,<span class="string">&quot;简答题题数量不够&quot;</span>, paper);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算试卷适应度</span></span><br><span class="line">            paper.setAdaptationDegree();</span><br><span class="line">            papers[i] = paper;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (initializeErrorMsg != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取种群中最优秀个体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ExaminationPaper <span class="title function_">getMostFitOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ExaminationPaper</span> <span class="variable">paper</span> <span class="operator">=</span> papers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; papers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (paper.getAdaptationDegree() &lt; papers[i].getAdaptationDegree()) &#123;</span><br><span class="line">                paper = papers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>计算适应度。 先根据每张试卷所有题目的难度、分值等参数计算出个体的难度系数，再根据难度系数计算初始种群中每个体的适应度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计算试卷个体难度系数</span></span><br><span class="line"><span class="comment">    *      计算公式： (难度*分数)/总分</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 难度系数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getDifficultyRate</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (difficulty == <span class="number">0.0</span>)&#123;</span><br><span class="line">           <span class="type">double</span> <span class="variable">stepDifficulty</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; questionList.length; i++) &#123;</span><br><span class="line">               <span class="keyword">for</span> (t_examination_question question : questionList[i]) &#123;</span><br><span class="line">                   stepDifficulty += rule.getQuestionScore()[i] * question.getDifficulty();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           stepDifficulty = stepDifficulty / (totalScore*<span class="number">2</span>);</span><br><span class="line">           <span class="built_in">this</span>.difficulty = stepDifficulty;</span><br><span class="line">           <span class="keyword">return</span> stepDifficulty;</span><br><span class="line">       &#125;<span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> difficulty;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计算个体适应度</span></span><br><span class="line"><span class="comment">    * ED为期望难度系数，D为种群个体难度系数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAdaptationDegree</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">double</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">switch</span> (rule.getDifficulty())&#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">               step = <span class="number">0.2</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">               step = <span class="number">0.3</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">               step = <span class="number">0.4</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       adaptationDegree = <span class="number">1</span> - Math.abs(step - getDifficultyRate());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>选择。选择是用来确定重组或交叉的个体，以及被选个体将产生多少子个体。按照上面得出的个体适应度进行父代个体的选择。可以挑选以下算法：轮盘赌选择、随机遍历抽样、局部选择、截断选择、锦标赛选择。我在此选择的是锦标赛选择方法，需要设置锦标赛选择规模系数j。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取指定规模下随机的种群中最优秀个体</span></span><br><span class="line"><span class="comment">    *  （用于锦标赛选择方法）</span></span><br><span class="line"><span class="comment">    *  如果规模大小 &gt; 种群数量大小，或小于0，则会返回null</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> scale 规模大小int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> ExaminationPaper <span class="title function_">getMostFitOne</span><span class="params">(<span class="type">int</span> scale)</span> &#123;</span><br><span class="line">       <span class="type">ExaminationPaper</span> <span class="variable">paper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (scale &gt; <span class="number">0</span> &amp;&amp; scale &lt;= papers.length)&#123;</span><br><span class="line">           ArrayList&lt;Integer&gt; selectPaperId = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; papers.length; i++) &#123;</span><br><span class="line">               selectPaperId.add(i);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; papers.length - scale; i++) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> random.nextInt(selectPaperId.size());</span><br><span class="line">               selectPaperId.remove(step);</span><br><span class="line">           &#125;</span><br><span class="line">           paper = papers[selectPaperId.get(<span class="number">0</span>)];</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; selectPaperId.size(); i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (paper.getAdaptationDegree() &lt; papers[selectPaperId.get(i)].getAdaptationDegree()) &#123;</span><br><span class="line">                   paper = papers[selectPaperId.get(i)];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> paper;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>交叉。基因重组是结合来自父代交配种群中的信息产生新的个体。依据个体编码表示方法的不同，可以有以下的算法：实值重组；离散重组；中间重组；线性重组；扩展线性重组。二进制交叉、单点交叉、多点交叉、均匀交叉、洗牌交叉、缩小代理交叉。我在实现过程中选择的是洗牌交叉，从一个父个体中取一半的基因，即一半的题目，再从另一个父个体中取一半，随机打乱后就生成了新的子个体基因。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 交叉产生下一代函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parent1</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parent2</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> ExaminationPaper <span class="title function_">crossover</span><span class="params">(ExaminationPaper parent1, ExaminationPaper parent2, examinationPaperMakeConfig rule)</span> &#123;</span><br><span class="line">      <span class="comment">// 创建child paper</span></span><br><span class="line">      <span class="type">ExaminationPaper</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExaminationPaper</span>(<span class="number">0</span>,rule.getTotalMark(),rule);</span><br><span class="line">      List&lt;TExaminationQuestion&gt;[] questionList = <span class="keyword">new</span> <span class="title class_">List</span>[<span class="number">5</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; questionList.length; i++) &#123;</span><br><span class="line">          questionList[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 储存交叉生成的子试卷中题目id，避免重复</span></span><br><span class="line">      List&lt;TExaminationQuestion&gt;[] parent1QuestionList = <span class="keyword">new</span> <span class="title class_">List</span>[<span class="number">5</span>];</span><br><span class="line">      List&lt;TExaminationQuestion&gt;[] parent2QuestionList = <span class="keyword">new</span> <span class="title class_">List</span>[<span class="number">5</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">          parent1QuestionList[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(parent1.getQuestionList()[i]);</span><br><span class="line">          parent2QuestionList[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(parent2.getQuestionList()[i]);</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      List&lt;Integer&gt; existQuestionId = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 子试卷题目数组一种题型目标大小</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">targetSize</span> <span class="operator">=</span> parent1QuestionList[i].size();</span><br><span class="line">          <span class="type">int</span> <span class="variable">runningTimes</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (run)&#123;</span><br><span class="line">              <span class="comment">//若满足条件则从父类1一中随机抽取一道不重复的题目添加</span></span><br><span class="line">              <span class="keyword">if</span> (parent1QuestionList[i]!=<span class="literal">null</span>)&#123;</span><br><span class="line">                  <span class="keyword">if</span> (parent1QuestionList[i].size() &gt; <span class="number">0</span> &amp;&amp; questionList[i].size()&lt;targetSize)&#123;</span><br><span class="line">                      <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> random.nextInt(parent1QuestionList[i].size());</span><br><span class="line">                      <span class="keyword">if</span> (!existQuestionId.contains(parent1QuestionList[i].get(step).getQuestionId()))&#123;</span><br><span class="line">                          questionList[i].add(parent1QuestionList[i].get(step));</span><br><span class="line">                          existQuestionId.add(parent1QuestionList[i].get(step).getQuestionId());</span><br><span class="line">                      &#125;</span><br><span class="line">                      parent1QuestionList[i].remove(step);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//若满足条件则从父类2一中随机抽取一道不重复的题目添加</span></span><br><span class="line">              <span class="keyword">if</span> (parent2QuestionList[i]!=<span class="literal">null</span>)&#123;</span><br><span class="line">                  <span class="keyword">if</span> (parent2QuestionList[i].size() &gt; <span class="number">0</span> &amp;&amp; questionList[i].size()&lt;targetSize)&#123;</span><br><span class="line">                      <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> random.nextInt(parent2QuestionList[i].size());</span><br><span class="line">                      <span class="keyword">if</span> (!existQuestionId.contains(parent2QuestionList[i].get(step).getQuestionId()))&#123;</span><br><span class="line">                          questionList[i].add(parent2QuestionList[i].get(step));</span><br><span class="line">                          existQuestionId.add(parent2QuestionList[i].get(step).getQuestionId());</span><br><span class="line">                      &#125;</span><br><span class="line">                      parent2QuestionList[i].remove(step);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (parent1QuestionList[i].size()==<span class="number">0</span> &amp;&amp; parent2QuestionList[i].size()==<span class="number">0</span> || questionList[i].size()&gt;=targetSize || runningTimes &gt; targetSize*<span class="number">2</span>)&#123;</span><br><span class="line">                  run = <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 避免死循环变量</span></span><br><span class="line">              runningTimes++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      child.setQuestionList(questionList);</span><br><span class="line">      <span class="keyword">return</span> child;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>变异。交叉之后子代经历的变异，实际上是子代基因按小概率扰动产生的变化。依据个体编码表示方法的不同，可以有以下的算法：实值变异、二进制变异。我使用的是实值变异，在进化的过程中每道题都将有k的概率会变异，发生变异后将从题库中抽取一道具有rule相关限定条件的新题目作为变异因子代替原有基因片段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 基因突变</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> paper</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mutate</span><span class="params">(ExaminationPaper paper)</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; paper.getQuestionList()[i].size(); j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (Math.random() &lt; mutationRate) &#123;</span><br><span class="line">                   <span class="type">TExaminationQuestion</span> <span class="variable">mutationQuestion</span> <span class="operator">=</span> paper.getQuestionList()[i].get(j);</span><br><span class="line">                   <span class="comment">// 设置数据库查询条件构造器</span></span><br><span class="line">                   <span class="type">QueryWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">                   wrapper.eq(<span class="string">&quot;difficulty&quot;</span>,mutationQuestion.getDifficulty());</span><br><span class="line">                   wrapper.eq(<span class="string">&quot;chapter&quot;</span>,mutationQuestion.getChapter());</span><br><span class="line">                   wrapper.eq(<span class="string">&quot;type&quot;</span>,mutationQuestion.getType());</span><br><span class="line">                   wrapper.eq(<span class="string">&quot;examination_course_id&quot;</span>,mutationQuestion.getExaminationCourseId());</span><br><span class="line">                   wrapper.eq(<span class="string">&quot;is_approved&quot;</span>,mutationQuestion.isApproved());</span><br><span class="line">                   wrapper.ne(<span class="string">&quot;question_id&quot;</span>,mutationQuestion.getQuestionId());</span><br><span class="line">                   <span class="comment">// 查询同条件下id不同的题目</span></span><br><span class="line">                   List&lt;TExaminationQuestion&gt; newQuestion = tExaminationQuestionDao.selectList(wrapper);</span><br><span class="line">                   <span class="keyword">if</span> (newQuestion.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                       <span class="comment">//System.out.println(&quot;发生基因突变了======原题目突变为新题目&quot;);</span></span><br><span class="line">                       <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                       paper.setQuestion(i,j,newQuestion.get(random.nextInt(newQuestion.size())));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进化。以种群为单位，逐步去执行进化算法使其适应环境，即适应度值更高。迭代过程中执行的进化算法就包括了选择、交叉、变异三个步骤。其中为了相对提高迭代收敛的速度，我弄了种群精英主义，即每一轮的进化过程中，保留该种群中最优秀的单一个体，即适应度最高的个体，添加至进化后的种群中，使种群的最优适应度始终&gt;=进化前种群。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 种群进化算法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> previousPopulation 原种群</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rule 种群规则</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> ExaminationPopulation <span class="title function_">evolvePopulation</span><span class="params">(ExaminationPopulation previousPopulation, examinationPaperMakeConfig rule)</span> &#123;</span><br><span class="line">      <span class="type">ExaminationPopulation</span> <span class="variable">newPopulation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExaminationPopulation</span>(previousPopulation.getLength(),rule,t_examination_questionDao,examinationDao);</span><br><span class="line">      <span class="comment">// 保留上一代最优秀个体</span></span><br><span class="line">      <span class="type">ExaminationPaper</span> <span class="variable">fitness</span> <span class="operator">=</span> previousPopulation.getMostFitOne();</span><br><span class="line">      fitness.setId(<span class="number">0</span>);</span><br><span class="line">      newPopulation.setPaper(<span class="number">0</span>, fitness);</span><br><span class="line">      <span class="comment">// 种群交叉操作，从当前的种群pop来创建下一代种群newPopulation</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; newPopulation.getLength(); i++) &#123;</span><br><span class="line">          <span class="comment">// 锦标赛选择方法 选择较优parent</span></span><br><span class="line">          <span class="type">ExaminationPaper</span> <span class="variable">parent1</span> <span class="operator">=</span> select(previousPopulation);</span><br><span class="line">          <span class="type">ExaminationPaper</span> <span class="variable">parent2</span> <span class="operator">=</span> select(previousPopulation);</span><br><span class="line">          <span class="keyword">while</span> (parent2.getId() == parent1.getId()) &#123;</span><br><span class="line">              parent2 = select(previousPopulation);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 交叉生成子试卷</span></span><br><span class="line">          <span class="type">ExaminationPaper</span> <span class="variable">child</span> <span class="operator">=</span> crossover(parent1, parent2, rule);</span><br><span class="line">          child.setId(i);</span><br><span class="line">          newPopulation.setPaper(i, child);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 进行种群变异</span></span><br><span class="line">      ExaminationPaper tmpPaper;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; newPopulation.getLength(); i++) &#123;</span><br><span class="line">          tmpPaper = newPopulation.getPaper(i);</span><br><span class="line">          <span class="comment">// 突变函数</span></span><br><span class="line">          mutate(tmpPaper);</span><br><span class="line">          <span class="comment">// 算出适应度</span></span><br><span class="line">          tmpPaper.setAdaptationDegree();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newPopulation;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://destinyol.github.io">pyf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://destinyol.github.io/2022/03/06/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8-%E9%A2%98%E5%BA%93%E6%99%BA%E8%83%BD%E7%BB%84%E5%8D%B7/">https://destinyol.github.io/2022/03/06/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8-%E9%A2%98%E5%BA%93%E6%99%BA%E8%83%BD%E7%BB%84%E5%8D%B7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://destinyol.github.io" target="_blank">pyf的日记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/">遗传算法</a></div><div class="post-share"><div class="social-share" data-image="https://s2.loli.net/2023/07/11/NhOuKfUn253GePM.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2022/03/13/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E6%95%B4/" title="遗传算法应用的性能调整"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">遗传算法应用的性能调整</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2022/02/17/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%BA%E6%99%AF/" title="MySQL索引失效的一些场景"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">MySQL索引失效的一些场景</div></div><div class="info-2"><div class="info-item-1">前言 我使用的MySQL版本是8 具体开发场景建议对语句是否能走索引进行测试，本文章列举的场景仅供参考 PS：在查询语句前加explain可以查看该条语句执行的一些信息   失效场景 1.索引列使用了函数 在索引列使用了函数进行处理，比如👇 1SELECT id,name FROM table WHERE UPPER(name) = &#x27;ABCD&#x27; 这样的查询会导致索引列失效，因为数据库要先进行全表扫描，获得数据之后再进行截取、计算，导致索引索引失效。同时，这样会导致需要全表扫描所有值，然后再计算比较，会增加数据库的计算开销，引发性能问题。 2.索引列参与了计算 这种场景和第一种场景差不多，就是索引类参与了一些运算，比如👇 1SELECT id,name FROM table WHERE (id + 1) = 5...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2022/03/13/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E6%95%B4/" title="遗传算法应用的性能调整"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-13</div><div class="info-item-2">遗传算法应用的性能调整</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/07/11/NhOuKfUn253GePM.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">pyf</div><div class="author-info-description">一个努力ing的后端程序员的博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://blog.csdn.net/destinyol?spm=1000.2115.3001.5343"><i class="fab fa-file-code-o"></i><span>CSDN</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/destinyol" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:godpitpy@foxmail.com" target="_blank" title="godpitpy@foxmail.com"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1037378522&amp;website=www.oicqzone.com" target="_blank" title="1037378522"><i class="fab fa-qq"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">遗传算法简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">算法的一些概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B51%EF%BC%9A%E5%9F%BA%E5%9B%A0%E5%92%8C%E6%9F%93%E8%89%B2%E4%BD%93"><span class="toc-number">2.1.1.</span> <span class="toc-text">概念1：基因和染色体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B52%EF%BC%9A%E9%80%82%E5%BA%94%E5%BA%A6%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">概念2：适应度函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B53%EF%BC%9A%E4%BA%A4%E5%8F%89"><span class="toc-number">2.1.3.</span> <span class="toc-text">概念3：交叉</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B54%EF%BC%9A%E5%8F%98%E5%BC%82"><span class="toc-number">2.1.4.</span> <span class="toc-text">概念4：变异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B55%EF%BC%9A%E5%A4%8D%E5%88%B6"><span class="toc-number">2.1.5.</span> <span class="toc-text">概念5：复制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">遗传算法的流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E5%AF%B9%E7%BB%84%E5%8D%B7%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">遗传算法对组卷问题的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E8%A7%A3%E7%9B%AE%E6%A0%87"><span class="toc-number">3.1.</span> <span class="toc-text">求解目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">限制条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B"><span class="toc-number">3.3.</span> <span class="toc-text">输入样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.4.</span> <span class="toc-text">算法实现步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%92%8C%E5%AF%B9%E5%BA%94%E6%A8%A1%E5%9E%8B%E5%85%B3%E7%B3%BB"><span class="toc-number">3.4.1.</span> <span class="toc-text">创建实体类和对应模型关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.2.</span> <span class="toc-text">具体实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.4.3.</span> <span class="toc-text">具体实现步骤</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/11/windows%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8Cbat%E8%84%9A%E6%9C%AC%E5%A4%B1%E8%B4%A5%E8%B8%A9%E5%9D%91/" title="windows计划任务执行bat脚本失败踩坑">windows计划任务执行bat脚本失败踩坑</a><time datetime="2025-04-11T01:30:37.000Z" title="发表于 2025-04-11 09:30:37">2025-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/06/Excel%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%A6%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%BC%82%E6%AD%A5%E5%AF%BC%E5%87%BA%E6%A1%86%E6%9E%B6/" title="Excel多线程带进度条异步导出框架">Excel多线程带进度条异步导出框架</a><time datetime="2025-01-06T01:43:13.000Z" title="发表于 2025-01-06 09:43:13">2025-01-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/Excel%E6%B5%81%E5%BC%8F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%A6%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AF%BC%E5%85%A5%E6%A1%86%E6%9E%B6/" title="Excel流式多线程带进度条功能的导入框架">Excel流式多线程带进度条功能的导入框架</a><time datetime="2024-12-26T04:05:43.000Z" title="发表于 2024-12-26 12:05:43">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/24/java%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%B1%9E%E6%80%A7%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%AA%8C%E7%A9%BA%E6%8A%9B%E9%94%99%E5%B7%A5%E5%85%B7/" title="Java实体类属性轻量级验空抛错工具">Java实体类属性轻量级验空抛错工具</a><time datetime="2024-10-24T01:35:39.000Z" title="发表于 2024-10-24 09:35:39">2024-10-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/16/sm2+sm4%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86%E6%9C%8D%E5%8A%A1%E9%97%B4%E5%BC%80%E6%94%BE%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83/" title="sm2+sm4混合加密服务间开放接口鉴权">sm2+sm4混合加密服务间开放接口鉴权</a><time datetime="2024-07-16T08:22:51.000Z" title="发表于 2024-07-16 16:22:51">2024-07-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By pyf</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>